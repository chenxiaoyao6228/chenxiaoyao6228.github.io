(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{587:function(a,s,t){"use strict";t.r(s);var n=t(7),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("p",[a._v("本节总结了入门canvas绘图中的必须要理解的一些基础概念.")]),a._v(" "),t("h2",{attrs:{id:"gui绘图基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gui绘图基础"}},[a._v("#")]),a._v(" GUI绘图基础")]),a._v(" "),t("p",[a._v("初次尝试canvas的朋友可能会发现一些Canvas的API和其他的web开发的API有所不同，比如在canvas中绘制一个矩形，需要先调用"),t("code",[a._v("ctx.beginPath()")]),a._v("，然后调用"),t("code",[a._v("ctx.rect()")]),a._v("，最后调用"),t("code",[a._v("ctx.fill()")]),a._v("或者"),t("code",[a._v("ctx.stroke()")]),a._v("。而在其他的web开发中，比如使用svg绘制矩形，只需要调用"),t("code",[a._v("<rect>")]),a._v("标签即可。")]),a._v(" "),t("p",[a._v("这种差异是由于Canvas开发和传统的web开发存在思维范式上的区别，这样的区别是由于两者的 API 范式导致的。图形 API 可以分为 "),t("strong",[a._v("保留模式(Retained mode) API")]),a._v(" 和 "),t("strong",[a._v("即时模式 API(Immediate Mode)")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"保留模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保留模式"}},[a._v("#")]),a._v(" 保留模式")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/images/graphics06.png",alt:""}})]),a._v(" "),t("p",[t("strong",[a._v("该模式几乎应用于所有的GUI系统中， 如HTML DOM、Windows")]),a._v("。")]),a._v(" "),t("p",[a._v("保留模式 API 是声明性的(通过类似HTML的DSL进行描述)。 应用程序从图形基元（如形状和线条）构造场景。 图形库将场景的模型存储在内存中。 若要绘制框架，图形库会将场景转换为一组绘图命令。 在帧之间，图形库将场景保留在内存中。 若要更改呈现的内容，应用程序会发出命令来更新场景，例如添加或删除形状。 然后，该库负责重绘场景。")]),a._v(" "),t("p",[a._v("这种模式的GUI存在的问题是"),t("strong",[a._v("性能")]),a._v("：创建和销毁GUI对象(通常它们是非常大的对象)导致内存占用高，UI反应迟缓。因此需要通过额外的方式减少创建和销毁的对象数量(比如React vdom)。同时必须编写大量代码来管理GUI对象的创建和销毁。(比如长列表需要做虚拟滚动)")]),a._v(" "),t("h3",{attrs:{id:"立即模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立即模式"}},[a._v("#")]),a._v(" 立即模式")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/images/graphics07.png",alt:""}})]),a._v(" "),t("p",[t("strong",[a._v("绝大多数游戏是这类模式，我们的Canvas API也属于此类")])]),a._v(" "),t("p",[a._v("即时模式 API 是过程性的，每次绘制新框架时，应用程序都会直接发出绘图命令，图形库不会在帧之间存储场景模型。")]),a._v(" "),t("p",[a._v("其优点是： 不需要分配内存，不需要对必须管理的对象进行创建和销毁操作，没有状态，也不需要注册或响应的事件或回调， 即使使用非常复杂的UI并且只有单线程的情况下也能相对好的效果。")]),a._v(" "),t("p",[a._v("但这也就意味着一旦图形绘制到canvas之中，我们就无法对画布的图形进行修改了，"),t("strong",[a._v("如果要实现对画布上元素的修改或者实现动效，唯一的方式就是重绘")]),a._v("。因此我们的canvas应用中都会有一个draw或者paint函数, 每次绘制的时候首先要通过ctx.clearRect清理画布，然后再进行绘制。")]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("draw")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("ctx")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 清理画布")]),a._v("\n    ctx"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("clearRect")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" canvas"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("width"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" canvas"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("height"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 执行绘制")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v('还有就是某些东西在canvas中实现比较麻烦。比如说"事件系统"，我们不能像在 dom 元素上监听事件一样在 canvas所渲染的图形内绑定各种事件。又比如说“绘制层级”，只能通过绘制时候的顺序和方式来处理层级。')]),a._v(" "),t("p",[a._v("立即模式的 API 更加底层，因此在基于实现复杂应用的时候必须构造一套类似HTML DOM面向对象系统 + 以及类似CSS的布局系统。看到这里大概就可以理解为什么绝大多数的 GUI 系统都是保留模式的了，框架已经帮你把脏活干完了。")]),a._v(" "),t("h2",{attrs:{id:"canvas元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canvas元素"}},[a._v("#")]),a._v(" canvas元素")]),a._v(" "),t("p",[a._v("可以通过css选择器获取canvas元素")]),a._v(" "),t("h2",{attrs:{id:"canvas元素的api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canvas元素的api"}},[a._v("#")]),a._v(" canvas元素的api")]),a._v(" "),t("p",[a._v("Canvas本身提供了 API 不多，目前有以下几个")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("canvas.width: 获取元素的宽度\ncanvas.height: 获取元素的高度\ncanvas.getContext(): 获取元素的绘图环境，包括2d和3d\ncanvas.toDataURL: 返回一个base64格式的链接\ncanvas.toBlob: 创建一个用于表示此canvas元素图像文件的blob \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("h2",{attrs:{id:"context对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#context对象"}},[a._v("#")]),a._v(" context对象")]),a._v(" "),t("h2",{attrs:{id:"canvas状态的保存与恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canvas状态的保存与恢复"}},[a._v("#")]),a._v(" canvas状态的保存与恢复")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考：")]),a._v(" "),t("ul",[t("li",[a._v("https://en.wikipedia.org/wiki/Retained_mode")]),a._v(" "),t("li",[a._v("https://en.wikipedia.org/wiki/Immediate_mode_GUI")]),a._v(" "),t("li",[a._v("https://zhuanlan.zhihu.com/p/534695668")]),a._v(" "),t("li",[a._v("保留模式与即时模式：https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/retained-mode-versus-immediate-mode")]),a._v(" "),t("li",[a._v("SVG与Canvas: https://learn.microsoft.com/zh-cn/previous-versions/windows/internet-explorer/ie-developer/samples/gg193983(v=vs.85)?redirectedfrom=MSDN")]),a._v(" "),t("li",[a._v("前端 4 种渲染技术的计算机理论基础： https://cloud.tencent.com/developer/article/1920658")]),a._v(" "),t("li",[a._v("GUI架构的两种模式与四种更新页面的手法: https://www.jianshu.com/p/65189d9d7b89")]),a._v(" "),t("li",[a._v("https://games.greggman.com/game/imgui-future/")]),a._v(" "),t("li",[a._v("https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/save")])])])}),[],!1,null,null,null);s.default=e.exports}}]);