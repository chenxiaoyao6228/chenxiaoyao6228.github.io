(window.webpackJsonp=window.webpackJsonp||[]).push([[282],{837:function(e,t,r){"use strict";r.r(t);var a=r(7),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("项目中有局域网投屏与文件传输的需求，所以研究了一下 webRTC，这里记录一下学习过程。")]),e._v(" "),r("h2",{attrs:{id:"webrtc-基本流程以及概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-基本流程以及概念"}},[e._v("#")]),e._v(" WebRTC 基本流程以及概念")]),e._v(" "),r("p",[e._v("下面以 1 对 1 音视频实时通话案例介绍 WebRTC 的基本流程以及概念")]),e._v(" "),r("h3",{attrs:{id:"webrtc-中的角色"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-中的角色"}},[e._v("#")]),e._v(" WebRTC 中的角色")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-1.png",alt:""}})]),e._v(" "),r("ul",[r("li",[r("p",[e._v("WebRTC 终端,负责音视频采集、编解码、NAT 穿越、音视频数据传输")])]),e._v(" "),r("li",[r("p",[e._v("Signal 服务器,负责信令处理,如加入房间、离开房间、媒体协商消息的传递等。")])]),e._v(" "),r("li",[r("p",[e._v("STUN/TURN 服务器,负责获取 WebRTC 终端在公网的 IP 地址,以及 NAT 穿越失败后的数据中转。")])])]),e._v(" "),r("h3",{attrs:{id:"媒体协商"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#媒体协商"}},[e._v("#")]),e._v(" 媒体协商")]),e._v(" "),r("p",[e._v("SDP(Session Description Protocal): 用文本描述的各端(PC 端、Mac 端、Android 端、iOS 端等)的能力。")]),e._v(" "),r("p",[e._v("这里的能力指的是"),r("strong",[e._v("各端所支持的音频编解码器是什么,这些编解码器设定的参数是什么,使用的传输协议是什么,以及包括的音视频媒体是什么")])]),e._v(" "),r("p",[e._v("媒体协商流程图")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-negociation.png",alt:""}})]),e._v(" "),r("ul",[r("li",[r("p",[e._v("呼叫方创建 Offer 类型的 SDP 消息。创建完成后,调用 setLocalDescriptoin 方法将该 Offer 保存到本地 Local 域,然后通过信令将 Offer 发送给被呼叫方。")])]),e._v(" "),r("li",[r("p",[e._v("被呼叫方收到 Offer 类型的 SDP 消息后,调用 setRemoteDescription 方法将 Offer 保存到它的 Remote 域。作为应答,被呼叫方要创建 Answer 类型的 SDP 消息,")])]),e._v(" "),r("li",[r("p",[e._v("Answer 消息创建成功后,再调用 setLocalDescription 方法将 Answer 类型的 SDP 消息保存到本地的 Local 域。最后,被呼叫方将 Answer 消息通过信令发送给呼叫方。")])]),e._v(" "),r("li",[r("p",[e._v("呼叫方收到 Answer 类型的消息后,调用 RTCPeerConnecton 对象的 setRemoteDescription 方法,将 Answer 保存到它的 Remote 域")])])]),e._v(" "),r("p",[e._v("具体的媒体协商的过程是 WebRTC 内部自己去实现的, 作为开发者"),r("strong",[e._v("只需要记住本地的 SDP 和远端的 SDP 都设置好后,协商就算成功了.")])]),e._v(" "),r("p",[e._v("紧接着在 "),r("strong",[e._v("WebRTC 底层会收集 Candidate")]),e._v(",并进行"),r("strong",[e._v("连通性检测")]),e._v(",最终在通话双方之间建立起一条链路来。")]),e._v(" "),r("h3",{attrs:{id:"webrtc-的连接-与-ice-candidate-重点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-的连接-与-ice-candidate-重点"}},[e._v("#")]),e._v(" WebRTC 的连接 与 ICE Candidate(重点)")]),e._v(" "),r("p",[e._v("WebRTC 之间建立连接的过程是非常复杂的, 主要的原因在于它内部的实现既要考虑传输的"),r("strong",[e._v("高效性")]),e._v(",又要保证端与端之间的"),r("strong",[e._v("连通率")]),e._v("。")]),e._v(" "),r("p",[e._v("当同时存在多个有效连接时,它首先选择传输质量最好的线路,如能用内网连通就不用公网。另外,如果尝试了很多线路都连通不了,那么它还会使用服务端中继的方式让双方连通")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-ice.png",alt:""}})]),e._v(" "),r("p",[e._v("WebRTC 是如何做到的? 答案是采用"),r("strong",[e._v("多个 Candicate 排序并执行连通性测试的方式")])]),e._v(" "),r("h3",{attrs:{id:"ice-candidate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ice-candidate"}},[e._v("#")]),e._v(" ICE Candidate")]),e._v(" "),r("p",[e._v("它表示 WebRTC 与远端通信时使用的协议、IP 地址和端口, 一般有以下字段")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-candidate.png",alt:""}})]),e._v(" "),r("p",[e._v("其中:")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("host 表示 "),r("strong",[e._v("本机候选者")])])]),e._v(" "),r("li",[r("p",[e._v("srflx 表示"),r("strong",[e._v("内网主机映射的外网的地址和端口(通过 TURN 服务器, 需要在 PeerConnectionConfig 里面去配)")])])]),e._v(" "),r("li",[r("p",[e._v("relay 表示中继候选者 "),r("strong",[e._v("(通过 TURN 服务器, 需要在 PeerConnectionConfig 里面去配)")]),e._v(",")])])]),e._v(" "),r("p",[e._v("假设 A 和 B 都有多个 candidate, 那么 WebRTC 会按照"),r("strong",[e._v("host->srflx→relay")]),e._v("的方式进行联通性测试, 选择最合适的方案")]),e._v(" "),r("p",[e._v("作为开发者, 只需要做两件事情:")]),e._v(" "),r("p",[e._v("1.部署相应的 TURN 服务器和 STUN 服务器(有现成的), 初始化 peerConnection 对象的时候配置 iceServers")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-init-turn-sturn.png",alt:""}})]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("监听 oniceccandidate 方法, 每接收到一个 candidate, 就通过信令服务器发送给另外一方即可")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-oniceccandidate.png",alt:""}})]),e._v(" "),r("p",[r("strong",[e._v("当我们没有设置 TURN 服务器或者 STUN 服务器的时候, 两个端建立起了连接, 就可以判断两个端位于同一个局域网内")])]),e._v(" "),r("h3",{attrs:{id:"stun-服务器与-nat-穿透"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stun-服务器与-nat-穿透"}},[e._v("#")]),e._v(" STUN 服务器与 NAT 穿透")]),e._v(" "),r("p",[e._v("如果两台主机不在同一个内网, WebRTC 将尝试 NAT 打洞,即 P2P 穿越。WebRTC 将 NAT 分类为 4 种类型")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("完全锥型")])]),e._v(" "),r("li",[r("p",[e._v("NAT IP 限制型")])]),e._v(" "),r("li",[r("p",[e._v("NAT 端口限制型")])]),e._v(" "),r("li",[r("p",[e._v("NAT 对称型 NAT")])])]),e._v(" "),r("p",[e._v("具体的穿透逻辑也是对开发者屏蔽的, 但基本的思路是: "),r("strong",[e._v("在公网上架设一台服务器,并向这台服务器发个请求, 该服务器往响应中塞入公网 IP , 这样客户端就可以知道自己的公网 IP")])]),e._v(" "),r("h3",{attrs:{id:"webrtc-兼容性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-兼容性"}},[e._v("#")]),e._v(" WebRTC 兼容性")]),e._v(" "),r("p",[e._v("从 can-i-use 中可以看到浏览器的支持情况还是相对乐观的")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-caniuse.png",alt:""}})]),e._v(" "),r("p",[e._v("但是直接使用 webrtc 原生的 API 还是比较麻烦的, 虽然浏览器支持了 WebRTC, 但是各大浏览器内部的实现方式还是有差异, 需要对应的 pollyfill 方案")]),e._v(" "),r("p",[e._v("目前只有 adaptor.js 可以选择, 可以官方推荐的方案")]),e._v(" "),r("h3",{attrs:{id:"基于原生-webrtc-的调用流程图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于原生-webrtc-的调用流程图"}},[e._v("#")]),e._v(" 基于原生 webrtc 的调用流程图")]),e._v(" "),r("p",[e._v("从上面的描述可以看到, 基于原生 WebRTC 去实现投屏功能的话还是比较麻烦的,")]),e._v(" "),r("p",[e._v("特别是 SDP 交换（createOffer 及 createAnswer）、网络候选信息收集(ICE candidate)")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-screen-share-logic-flow.png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"peerjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#peerjs"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://www.npmjs.com/package/peerjs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Peerjs"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("peerjs 简化了 webrtc 的开发过程，把 SDP 交换、ICE candidate 这些偏底层的细节都做了封装，开发人员只需要关注应用本身就行了。")]),e._v(" "),r("p",[e._v("peerjs 的核心对象 Peer，它有几个常用方法：")]),e._v(" "),r("ul",[r("li",[e._v("peer.connect 创建点对点的连接")]),e._v(" "),r("li",[e._v("peer.call 向另 1 个 peer 端发起音视频实时通信")]),e._v(" "),r("li",[e._v("peer.on 对各种事件的监控回调")]),e._v(" "),r("li",[e._v("peer.disconnect 断开连接")]),e._v(" "),r("li",[e._v("peer.reconnect 重新连接")]),e._v(" "),r("li",[e._v("peer.destroy 销毁对象")])]),e._v(" "),r("p",[e._v("另外还有二个重要对象 DataConnection、MediaConnection，其中：")]),e._v(" "),r("ul",[r("li",[e._v("DataConnection 用于收发数据(对应于 webrtc 中的 DataChannel)，它的所有方法中有一个重要的 send 方法，用于向另一个 peer 端发送数据；")]),e._v(" "),r("li",[e._v("MediaConnection 用于处理媒体流，它有一个重要的 stream 属性，表示关联的媒体流。")])]),e._v(" "),r("p",[e._v("peerjs 内置了一套信令服务器, peer-server, 开发者可以自己部署, 不指定的情况下会使用 peerjs 官方托管的信令服务器")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/chenxiaoyao6228/cloudimg@main/2023/webrtc-peerjs-peerserver.png",alt:""}})]),e._v(" "),r("p",[e._v("总结：")]),e._v(" "),r("ul",[r("li",[e._v("相比原生的方案, api 简化, 开发者关注底层的细节少了")]),e._v(" "),r("li",[e._v("提供了 peer-server 可供部署, 官方也提供免费托管的 peerServer")]),e._v(" "),r("li",[e._v("封装程度比较高, 后续改造会比较麻烦")])]),e._v(" "),r("h2",{attrs:{id:"simple-peer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#simple-peer"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://www.npmjs.com/package/simple-peer",target:"_blank",rel:"noopener noreferrer"}},[e._v("Simple-peer"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("与 peerjs 类似, 把 SDP 交换、ICE candidate 这些偏底层的细节都做了封装, 但是封装程度没有 peerjs 那么高, 提供了一定的灵活性:")]),e._v(" "),r("p",[e._v("peer.signal(data): 发送信令")]),e._v(" "),r("p",[e._v("peer.send(data): 发送 data")]),e._v(" "),r("p",[e._v("peer.addStream(stream): 添加音视频流")]),e._v(" "),r("p",[e._v("peer.removeStream(stream): 移除音视频流")]),e._v(" "),r("p",[e._v("peer.addTrack(track, stream)")]),e._v(" "),r("p",[e._v("peer.removeTrack(track, stream)")]),e._v(" "),r("p",[e._v("peer.destroy([err]): 销毁实例")]),e._v(" "),r("p",[e._v("peer.on(): 监听各种事件")]),e._v(" "),r("p",[r("strong",[e._v("相比 peerjs, simple-peerjs 自己并不提供 peerServer 作为信令服务器, 而是提供了一个 signal 事件")])]),e._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[e._v("peer"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("on")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"signal"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("data")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// when peer1 has signaling data, give it to peer2 somehow")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 在这里使用IM发送信令")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("总结：")]),e._v(" "),r("ul",[r("li",[e._v("一定程度的封装, 相比原生不需要写很多冗余的样板代码，但也意味着一个高级功能的实现需要自己来实现(peerjs 有文件传输相关的实现)")]),e._v(" "),r("li",[e._v("相比 peerjs, 不依赖 peerServer, 可以接入我们的 IM")]),e._v(" "),r("li",[e._v("总代码不到一千行, 且不依赖 server 代码, 改造起来比较容易")])]),e._v(" "),r("h2",{attrs:{id:"一些注意事项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一些注意事项"}},[e._v("#")]),e._v(" 一些注意事项")]),e._v(" "),r("h3",{attrs:{id:"https-限制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https-限制"}},[e._v("#")]),e._v(" https 限制")]),e._v(" "),r("p",[e._v("由于浏览器的安全限制, 本地开发的时候需要使用 localhost 访问, 或者配置 https 证书, 不然无法拿到 navigator.mediaDevices 对象")]),e._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://webrtc.github.io/samples/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webrtc-samples"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://webrtc.org/getting-started/overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("google webrtc"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.npmjs.com/package/peerjs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Peerjs"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.npmjs.com/package/simple-peer",target:"_blank",rel:"noopener noreferrer"}},[e._v("Simple-peer"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://time.geekbang.org/column/article/107916",target:"_blank",rel:"noopener noreferrer"}},[e._v("从 0 打造音视频直播系统"),r("OutboundLink")],1)])])])])}),[],!1,null,null,null);t.default=s.exports}}]);