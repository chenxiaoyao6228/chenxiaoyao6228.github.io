(window.webpackJsonp=window.webpackJsonp||[]).push([[313],{870:function(v,t,_){"use strict";_.r(t);var a=_(7),n=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("2.2 包围盒\n既然有了虚拟节点，那知道每个虚拟节点的位置和大小也比较重要，它会涉及到判断两个图形是否相交、事件等等。")]),v._v(" "),_("p",[v._v("有时候元素的形状不是很规则，如果直接对不规则元素进行碰撞检测会比较麻烦，所以就有了一个近似的算法，就是在物体外侧加上包围盒，如图：")]),v._v(" "),_("p",[v._v("目前主流的包围盒有 AABB 和 OBB 两种。")]),v._v(" "),_("p",[v._v("AABB 包围盒：")]),v._v(" "),_("p",[v._v("实现方式简单，直接用最大最小的横纵坐标来生成包围盒，但不会跟着元素旋转，因此空白区域比较多，也不够准确。")]),v._v(" "),_("p",[v._v("也是目前 Konva 和 AntV 使用的方式。（适合表格业务）")]),v._v(" "),_("p",[v._v("OBB 包围盒：")]),v._v(" "),_("p",[v._v("实现方式相对复杂，通过构建协方差矩阵来计算出新的坐标轴方向，将其顶点投射到坐标轴上面来得到新的包围盒。")]),v._v(" "),_("p",[v._v("所以 OBB 包围盒更加准确一些，也是 cocos2d 使用的方式。")]),v._v(" "),_("p",[v._v("碰撞检测：")]),v._v(" "),_("p",[v._v("两个包围盒在所有轴（与边平行）上的投影都发生重叠，则判定为碰撞；否则，没有发生碰撞。")]),v._v(" "),_("p",[v._v("虽然从数学意义上，我们可以通过诸如 射线法 等算法判断，但由于内容千变万化，在非常复杂的图形上，难以依靠数学计算得以解决，因此这里我们将利用 canvas 本身的特性，使用一种取巧的方式，解决鼠标的命中问题，思路如下：\n我们先对 canvas 画布内的每个元素添加唯一的 id，并设计一种 id 与 rgba 互相转换的算法，然后再建立一个与当前画布等大的“影子画布”（不必显示在页面上），我们将用户能看见的画布称为 A，影子画布为 B，每当在 A 上渲染一个元素的时候，同步在 B 上的相同位置渲染一个等大的元素，并以其 id 所转换的 rgba 值填充。这样，当鼠标处于 A 上时，可通过当前坐标和 getImageData 可找到 B 上对应点的 rgba 值，将 rgba 反转为 id，即可知晓被选中的元素\n为此，首先我们需要一个函数 createId 生成 id，两个转换函数 idToRgba 和 rgbaToId")])])}),[],!1,null,null,null);t.default=n.exports}}]);